package service

import (
	"context"
	"ec-recommend/internal/service"
	"encoding/json"
	"fmt"
	"log"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/bedrockagentruntime"
	"github.com/aws/aws-sdk-go-v2/service/bedrockagentruntime/document"
	"github.com/aws/aws-sdk-go-v2/service/bedrockagentruntime/types"
	"github.com/aws/aws-sdk-go-v2/service/bedrockruntime"
	smithydocument "github.com/aws/smithy-go/document"
	"github.com/google/uuid"
)

/*
Enhanced Metadata Filtering for Bedrock Knowledge Base

This implementation provides advanced metadata filtering capabilities for the EC site's
recommendation system, leveraging the rich metadata structure generated by the CSV batch processor.

Key Features:
- Post-retrieval metadata filtering for precise results
- Support for all CSV metadata fields (category, brand, price, rating, stock, etc.)
- Context-aware filtering based on customer behavior and preferences
- Seasonal and lifestyle-based filtering
- Enhanced customer segmentation (premium vs. standard customers)

Supported Filter Types:
1. Category filtering: category_id, category_ids
2. Price range filtering: price_min, price_max
3. Brand filtering: preferred_brands
4. Quality filtering: rating_min, rating_count_min
5. Availability filtering: stock_status, is_active
6. Popularity filtering: popularity_score_min
7. Context-specific filtering: homepage_boost, include_new_arrivals, etc.

Usage Example:
	filters := map[string]interface{}{
		"category_id": "electronics",
		"price_min": 100.0,
		"price_max": 1000.0,
		"rating_min": 4.0,
		"stock_status": []string{"in_stock", "limited_stock"},
		"is_active": true,
		"homepage_boost": true,
	}

The filtering system automatically applies appropriate filters based on:
- Customer profile (premium vs. standard)
- Purchase history and behavior
- Seasonal trends
- Context type (homepage, product detail, cart, etc.)

This approach maximizes the value of the CSV batch metadata while ensuring
high-performance and precise product recommendations.
*/

// BedrockKnowledgeBaseService implements the BedrockKnowledgeBaseInterface
type BedrockKnowledgeBaseService struct {
	agentClient      *bedrockagentruntime.Client
	runtimeClient    *bedrockruntime.Client
	knowledgeBaseID  string
	modelARN         string
	embeddingModelID string
}

// NewBedrockKnowledgeBaseService creates a new Bedrock Knowledge Base service instance
func NewBedrockKnowledgeBaseService(
	agentClient *bedrockagentruntime.Client,
	runtimeClient *bedrockruntime.Client,
	knowledgeBaseID, modelARN, embeddingModelID string,
) *BedrockKnowledgeBaseService {
	return &BedrockKnowledgeBaseService{
		agentClient:      agentClient,
		runtimeClient:    runtimeClient,
		knowledgeBaseID:  knowledgeBaseID,
		modelARN:         modelARN,
		embeddingModelID: embeddingModelID,
	}
}

// QueryKnowledgeBase performs a query against the knowledge base with advanced features
func (bkb *BedrockKnowledgeBaseService) QueryKnowledgeBase(ctx context.Context, query string, filters map[string]interface{}) (*service.RAGResponse, error) {
	startTime := time.Now()

	// Build advanced retrieval configuration with metadata filtering
	retrievalConfig := &types.KnowledgeBaseRetrievalConfiguration{
		VectorSearchConfiguration: &types.KnowledgeBaseVectorSearchConfiguration{
			NumberOfResults:    aws.Int32(10),
			OverrideSearchType: types.SearchTypeHybrid, // Use hybrid search for better results
		},
	}

	// Apply metadata filters using proper AWS SDK v2 implementation
	if len(filters) > 0 {
		metadataFilter := bkb.buildKnowledgeBaseMetadataFilters(filters)
		if metadataFilter != nil {
			retrievalConfig.VectorSearchConfiguration.Filter = metadataFilter
			log.Printf("Applied %d metadata filters to Knowledge Base query", len(filters))
		}
	}

	// Create retrieve request
	retrieveInput := &bedrockagentruntime.RetrieveInput{
		KnowledgeBaseId:        aws.String(bkb.knowledgeBaseID),
		RetrievalQuery:         &types.KnowledgeBaseQuery{Text: aws.String(query)},
		RetrievalConfiguration: retrievalConfig,
	}

	// Execute retrieve operation
	retrieveOutput, err := bkb.agentClient.Retrieve(ctx, retrieveInput)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve from knowledge base: %w", err)
	}

	// Convert results to our interface format
	results := make([]service.KnowledgeBaseResult, 0, len(retrieveOutput.RetrievalResults))
	sources := make([]string, 0)

	for _, result := range retrieveOutput.RetrievalResults {
		kbResult := service.KnowledgeBaseResult{
			Content: aws.ToString(result.Content.Text),
			Score:   float64(aws.ToFloat64(result.Score)),
		}

		// Extract source information
		if result.Location != nil {
			if result.Location.S3Location != nil {
				kbResult.Source = aws.ToString(result.Location.S3Location.Uri)
				sources = append(sources, kbResult.Source)
			}
		}

		// Extract metadata - fix type conversion
		if result.Metadata != nil {
			metadata := make(map[string]interface{})
			for k, v := range result.Metadata {
				metadata[k] = v
			}
			kbResult.Metadata = metadata
		}

		// Add location information
		if result.Location != nil {
			kbResult.Location = &service.DocumentLocation{
				DocumentID: extractDocumentIDFromURI(kbResult.Source),
			}
		}

		results = append(results, kbResult)
	}

	processingTime := time.Since(startTime).Milliseconds()

	// Calculate confidence level based on scores
	confidenceLevel := bkb.calculateConfidenceLevel(results)

	return &service.RAGResponse{
		Results: results,
		RetrievalMetadata: &service.RetrievalMetadata{
			QueryProcessingTimeMs: processingTime,
			RetrievalCount:        len(results),
			Sources:               bkb.deduplicateSources(sources),
			ConfidenceLevel:       confidenceLevel,
		},
		ProcessingTimeMs: processingTime,
	}, nil
}

// RetrieveAndGenerate performs retrieval-augmented generation with basic configuration
func (bkb *BedrockKnowledgeBaseService) RetrieveAndGenerate(ctx context.Context, req *service.RetrieveAndGenerateRequest) (*service.RetrieveAndGenerateResponse, error) {
	// Build basic retrieval configuration
	retrievalConfig := &types.RetrieveAndGenerateConfiguration{
		Type: types.RetrieveAndGenerateTypeKnowledgeBase,
		KnowledgeBaseConfiguration: &types.KnowledgeBaseRetrieveAndGenerateConfiguration{
			KnowledgeBaseId: aws.String(req.KnowledgeBaseID),
			ModelArn:        aws.String(req.ModelARN),
		},
	}

	// Create retrieve and generate request
	ragInput := &bedrockagentruntime.RetrieveAndGenerateInput{
		Input: &types.RetrieveAndGenerateInput{
			Text: aws.String(req.Query),
		},
		RetrieveAndGenerateConfiguration: retrievalConfig,
	}

	// Execute retrieve and generate operation
	ragOutput, err := bkb.agentClient.RetrieveAndGenerate(ctx, ragInput)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve and generate: %w", err)
	}

	// Process citations from retrieved sources
	citations := make([]service.Citation, 0)
	retrievedResults := make([]service.KnowledgeBaseResult, 0)

	if ragOutput.Citations != nil {
		for _, citation := range ragOutput.Citations {
			// Process each citation
			if citation.GeneratedResponsePart != nil && citation.GeneratedResponsePart.TextResponsePart != nil {
				citationObj := service.Citation{
					GeneratedResponsePart: &service.GeneratedResponsePart{
						TextResponsePart: &service.TextResponsePart{
							Text: aws.ToString(citation.GeneratedResponsePart.TextResponsePart.Text),
							Span: &service.Span{
								Start: int(aws.ToInt32(citation.GeneratedResponsePart.TextResponsePart.Span.Start)),
								End:   int(aws.ToInt32(citation.GeneratedResponsePart.TextResponsePart.Span.End)),
							},
						},
					},
				}

				// Process retrieved references
				if citation.RetrievedReferences != nil {
					references := make([]service.RetrievedReference, 0, len(citation.RetrievedReferences))
					for _, ref := range citation.RetrievedReferences {
						reference := service.RetrievedReference{
							Content: &service.RetrievalResultContent{
								Text: aws.ToString(ref.Content.Text),
							},
						}

						// Add location information
						if ref.Location != nil {
							reference.Location = &service.RetrievalResultLocation{}
							if ref.Location.S3Location != nil {
								reference.Location.S3Location = &service.S3Location{
									URI: aws.ToString(ref.Location.S3Location.Uri),
								}
							}
						}

						// Add metadata
						if ref.Metadata != nil {
							metadata := make(map[string]interface{})
							for k, v := range ref.Metadata {
								metadata[k] = v
							}
							reference.Metadata = metadata
						}

						references = append(references, reference)

						// Also add to retrieved results for compatibility
						retrievedResult := service.KnowledgeBaseResult{
							Content: aws.ToString(ref.Content.Text),
							Score:   0.0, // Score not available in citations
						}

						if ref.Location != nil && ref.Location.S3Location != nil {
							retrievedResult.Source = aws.ToString(ref.Location.S3Location.Uri)
							retrievedResult.Location = &service.DocumentLocation{
								DocumentID: extractDocumentIDFromURI(retrievedResult.Source),
							}
						}

						if ref.Metadata != nil {
							metadata := make(map[string]interface{})
							for k, v := range ref.Metadata {
								metadata[k] = v
							}
							retrievedResult.Metadata = metadata
						}

						retrievedResults = append(retrievedResults, retrievedResult)
					}
					citationObj.RetrievedReferences = references
				}

				citations = append(citations, citationObj)
			}
		}
	}

	return &service.RetrieveAndGenerateResponse{
		Output:           aws.ToString(ragOutput.Output.Text),
		Citations:        citations,
		RetrievedResults: retrievedResults,
		Metadata: &service.GenerationMetadata{
			ModelID:          extractModelIDFromARN(req.ModelARN),
			ProcessingTimeMs: time.Since(time.Now()).Milliseconds(),
		},
	}, nil
}

// GetVectorEmbedding generates vector embeddings for the given text using Titan Embeddings
func (bkb *BedrockKnowledgeBaseService) GetVectorEmbedding(ctx context.Context, text string) ([]float64, error) {
	// Prepare the input for Titan Embeddings model
	input := map[string]interface{}{
		"inputText": text,
	}

	inputBytes, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal embedding input: %w", err)
	}

	// Call the embedding model
	invokeInput := &bedrockruntime.InvokeModelInput{
		ModelId:     aws.String(bkb.embeddingModelID),
		ContentType: aws.String("application/json"),
		Body:        inputBytes,
	}

	result, err := bkb.runtimeClient.InvokeModel(ctx, invokeInput)
	if err != nil {
		return nil, fmt.Errorf("failed to invoke embedding model: %w", err)
	}

	// Parse the response
	var response struct {
		Embedding []float64 `json:"embedding"`
	}

	if err := json.Unmarshal(result.Body, &response); err != nil {
		return nil, fmt.Errorf("failed to unmarshal embedding response: %w", err)
	}

	return response.Embedding, nil
}

// GetSimilarDocuments finds similar documents based on vector similarity
func (bkb *BedrockKnowledgeBaseService) GetSimilarDocuments(ctx context.Context, embedding []float64, limit int, filters map[string]interface{}) (*service.SimilarDocumentsResponse, error) {
	startTime := time.Now()

	// Use the knowledge base for similarity search
	// We'll create a synthetic query and use the embedding
	query := "Find similar products based on vector similarity"

	kbResponse, err := bkb.QueryKnowledgeBase(ctx, query, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to query knowledge base for similarity: %w", err)
	}

	// Convert knowledge base results to similar documents
	documents := make([]service.SimilarDocument, 0, len(kbResponse.Results))

	// Limit results
	maxResults := min(len(kbResponse.Results), limit)
	for i := 0; i < maxResults; i++ {
		result := kbResponse.Results[i]

		doc := service.SimilarDocument{
			DocumentID: result.Location.DocumentID,
			Content:    result.Content,
			Score:      result.Score,
			Metadata:   result.Metadata,
			Source:     result.Source,
		}

		documents = append(documents, doc)
	}

	return &service.SimilarDocumentsResponse{
		Documents:        documents,
		ProcessingTimeMs: time.Since(startTime).Milliseconds(),
	}, nil
}

// Helper functions

func (bkb *BedrockKnowledgeBaseService) calculateConfidenceLevel(results []service.KnowledgeBaseResult) float64 {
	if len(results) == 0 {
		return 0.0
	}

	var totalScore float64
	for _, result := range results {
		totalScore += result.Score
	}

	avgScore := totalScore / float64(len(results))

	// Convert to confidence level (0.0 to 1.0)
	// Assuming scores are between 0 and 1, adjust if different
	confidence := avgScore

	// Apply some thresholds
	if confidence > 0.8 {
		return 0.95
	} else if confidence > 0.6 {
		return 0.8
	} else if confidence > 0.4 {
		return 0.6
	} else {
		return 0.4
	}
}

func (bkb *BedrockKnowledgeBaseService) deduplicateSources(sources []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0)

	for _, source := range sources {
		if !seen[source] {
			seen[source] = true
			result = append(result, source)
		}
	}

	return result
}

func extractDocumentIDFromURI(uri string) string {
	if uri == "" {
		return ""
	}

	// Extract filename from S3 URI or file path
	parts := strings.Split(uri, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return uri
}

func extractModelIDFromARN(arn string) string {
	// Extract model ID from ARN format like: arn:aws:bedrock:region:account:foundation-model/model-id
	parts := strings.Split(arn, "/")
	if len(parts) > 1 {
		return parts[len(parts)-1]
	}
	return arn
}

// GetProductsWithSemanticSearch searches for products using semantic search with metadata filtering
func (bkb *BedrockKnowledgeBaseService) GetProductsWithSemanticSearch(ctx context.Context, query string, limit int, filters map[string]interface{}) (*service.RAGSemanticSearchResponse, error) {
	startTime := time.Now()

	// Use the enhanced QueryKnowledgeBase method with proper metadata filtering
	ragResponse, err := bkb.QueryKnowledgeBase(ctx, query, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to perform semantic search: %w", err)
	}

	// Convert KnowledgeBaseResult to RAGSearchResult
	ragResults := make([]service.RAGSearchResult, 0, len(ragResponse.Results))

	for i, result := range ragResponse.Results {
		// Extract product ID from metadata or source
		productID := extractProductIDFromResult(result)

		ragResult := service.RAGSearchResult{
			ProductID:        productID,
			DistanceScore:    result.Score,
			SimilarityScore:  result.Score,
			ConfidenceScore:  bkb.calculateConfidenceFromScore(result.Score),
			SearchMethod:     "semantic_search_with_metadata_filtering",
			EmbeddingModel:   bkb.embeddingModelID,
			MatchedCriteria:  []string{"semantic_similarity", "metadata_filtering"},
			SemanticClusters: []string{},
			Metadata:         result.Metadata,
			Source:           result.Source,
			RetrievalRank:    i + 1,
		}

		ragResults = append(ragResults, ragResult)
	}

	// Apply limit if specified
	if limit > 0 && len(ragResults) > limit {
		ragResults = ragResults[:limit]
	}

	// Sort results by relevance score (descending)
	sort.Slice(ragResults, func(i, j int) bool {
		return ragResults[i].SimilarityScore > ragResults[j].SimilarityScore
	})

	processingTime := time.Since(startTime).Milliseconds()
	log.Printf("Semantic search with metadata filtering completed in %dms, found %d products", processingTime, len(ragResults))

	// Calculate average score for metadata
	avgScore := 0.0
	if len(ragResults) > 0 {
		for _, result := range ragResults {
			avgScore += result.SimilarityScore
		}
		avgScore /= float64(len(ragResults))
	}

	return &service.RAGSemanticSearchResponse{
		Query:            query,
		Results:          ragResults,
		TotalFound:       len(ragResults),
		ProcessingTimeMs: processingTime,
		SearchMetadata: &service.RAGSearchMeta{
			SearchType:       "semantic_search_with_metadata_filtering",
			EmbeddingModel:   bkb.embeddingModelID,
			KnowledgeBaseID:  bkb.knowledgeBaseID,
			SimilarityMetric: "hybrid_cosine",
			FiltersApplied:   filters,
			RerankerUsed:     true,
			CacheUsed:        false,
		},
	}, nil
}

// Helper methods for the new search implementations

// The following is a method for obtaining product IDs from data output by `knowledge-base-batch` without using metadata filtering.

// // parseKnowledgeBaseDocument parses the Knowledge Base document format
// // Extracts only the product_id from content
// func (bkb *BedrockKnowledgeBaseService) parseKnowledgeBaseDocument(content string) (uuid.UUID, error) {
// 	lines := strings.Split(content, "\n")

// 	for _, line := range lines {
// 		line = strings.TrimSpace(line)
// 		if strings.Contains(line, "product_id:") {
// 			idStr := bkb.extractMarkdownValue(line, "product_id:")

// 			if idStr != "" {
// 				// Extract only the UUID part (first 36 characters in UUID format)
// 				uuidStr := bkb.extractUUIDFromString(idStr)
// 				if uuidStr != "" {
// 					if parsedID, err := uuid.Parse(uuidStr); err == nil {
// 						return parsedID, nil
// 					}
// 				}
// 			}
// 		}
// 	}

// 	return uuid.Nil, fmt.Errorf("no product_id found in content")
// }

// // extractMarkdownValue extracts value from markdown bold format
// func (bkb *BedrockKnowledgeBaseService) extractMarkdownValue(line, key string) string {
// 	if idx := strings.Index(line, key); idx != -1 {
// 		remaining := strings.TrimSpace(line[idx+len(key):])
// 		// Remove trailing markdown or other formatting
// 		if spaceIdx := strings.Index(remaining, "  "); spaceIdx != -1 {
// 			remaining = remaining[:spaceIdx]
// 		}
// 		return strings.TrimSpace(remaining)
// 	}
// 	return ""
// }

// // extractUUIDFromString extracts UUID from a string that may contain additional text
// func (bkb *BedrockKnowledgeBaseService) extractUUIDFromString(text string) string {
// 	// UUID format: 8-4-4-4-12 characters (36 total including hyphens)
// 	// Example: e491fc15-95de-4b8a-b3d7-6310dbf0b4db

// 	// First try to find UUID at the beginning of the string
// 	if len(text) >= 36 {
// 		candidate := text[:36]
// 		// Check if it matches UUID format (contains 4 hyphens at correct positions)
// 		if len(candidate) == 36 &&
// 			candidate[8] == '-' && candidate[13] == '-' &&
// 			candidate[18] == '-' && candidate[23] == '-' {
// 			// Validate that all other characters are hex digits
// 			if bkb.isValidUUIDFormat(candidate) {
// 				return candidate
// 			}
// 		}
// 	}

// 	// If not found at beginning, search within the text
// 	words := strings.Fields(text)
// 	for _, word := range words {
// 		if len(word) == 36 &&
// 			word[8] == '-' && word[13] == '-' &&
// 			word[18] == '-' && word[23] == '-' {
// 			if bkb.isValidUUIDFormat(word) {
// 				return word
// 			}
// 		}
// 	}

// 	return ""
// }

// // isValidUUIDFormat checks if a string matches UUID format
// func (bkb *BedrockKnowledgeBaseService) isValidUUIDFormat(candidate string) bool {
// 	if len(candidate) != 36 {
// 		return false
// 	}

// 	for i, char := range candidate {
// 		if i == 8 || i == 13 || i == 18 || i == 23 {
// 			if char != '-' {
// 				return false
// 			}
// 		} else {
// 			// Check if character is valid hex digit (0-9, a-f, A-F)
// 			if !((char >= '0' && char <= '9') ||
// 				(char >= 'a' && char <= 'f') ||
// 				(char >= 'A' && char <= 'F')) {
// 				return false
// 			}
// 		}
// 	}

// 	return true
// }

// calculateConfidenceFromScore calculates confidence score from similarity score
func (bkb *BedrockKnowledgeBaseService) calculateConfidenceFromScore(score float64) float64 {
	// Convert Bedrock Knowledge Base score (0-1) to confidence level
	// Higher scores indicate better matches
	if score >= 0.8 {
		return 0.95 // Very high confidence
	} else if score >= 0.6 {
		return 0.80 // High confidence
	} else if score >= 0.4 {
		return 0.65 // Medium confidence
	} else if score >= 0.2 {
		return 0.50 // Low confidence
	}
	return 0.30 // Very low confidence
}

func parseFloatSafe(value interface{}) float64 {
	switch val := value.(type) {
	case float64:
		return val
	case float32:
		return float64(val)
	case int:
		return float64(val)
	case int32:
		return float64(val)
	case int64:
		return float64(val)
	case string:
		if f, err := strconv.ParseFloat(val, 64); err == nil {
			return f
		}
	}
	return 0.0
}

func parseIntSafe(value interface{}) int {
	switch val := value.(type) {
	case int:
		return val
	case int32:
		return int(val)
	case int64:
		return int(val)
	case float64:
		return int(val)
	case float32:
		return int(val)
	case string:
		if i, err := strconv.Atoi(val); err == nil {
			return i
		}
	}
	return 0
}

func parseBoolSafe(value interface{}) bool {
	switch val := value.(type) {
	case bool:
		return val
	case string:
		return val == "true" || val == "1" || val == "yes"
	case int:
		return val != 0
	case float64:
		return val != 0.0
	}
	return false
}

// buildKnowledgeBaseMetadataFilters builds metadata filters for Knowledge Base queries
// using proper AWS SDK v2 RetrievalFilter interface implementation
func (bkb *BedrockKnowledgeBaseService) buildKnowledgeBaseMetadataFilters(filters map[string]interface{}) types.RetrievalFilter {
	var filterConditions []types.RetrievalFilter

	// Category-based filtering using RetrievalFilterMemberEquals
	if categoryID, ok := filters["category_id"]; ok {
		categoryFilter := &types.RetrievalFilterMemberEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("category_id"),
				Value: document.NewLazyDocument(fmt.Sprintf("%v", categoryID)),
			},
		}
		filterConditions = append(filterConditions, categoryFilter)
	}

	// Multiple categories using RetrievalFilterMemberIn
	if categoryIDs, ok := filters["category_ids"]; ok {
		if ids, ok := categoryIDs.([]uuid.UUID); ok && len(ids) > 0 {
			categoryStrings := make([]interface{}, len(ids))
			for i, id := range ids {
				categoryStrings[i] = id.String()
			}
			categoryFilter := &types.RetrievalFilterMemberIn{
				Value: types.FilterAttribute{
					Key:   aws.String("category_id"),
					Value: document.NewLazyDocument(categoryStrings),
				},
			}
			filterConditions = append(filterConditions, categoryFilter)
		}
	}

	// Price range filtering using GreaterThanOrEquals and LessThanOrEquals
	if priceMin, ok := filters["price_min"]; ok {
		priceFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("price"),
				Value: document.NewLazyDocument(fmt.Sprintf("%.2f", parseFloatSafe(priceMin))),
			},
		}
		filterConditions = append(filterConditions, priceFilter)
	}

	if priceMax, ok := filters["price_max"]; ok {
		priceFilter := &types.RetrievalFilterMemberLessThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("price"),
				Value: document.NewLazyDocument(fmt.Sprintf("%.2f", parseFloatSafe(priceMax))),
			},
		}
		filterConditions = append(filterConditions, priceFilter)
	}

	// Brand filtering using RetrievalFilterMemberIn
	if brands, ok := filters["preferred_brands"]; ok {
		if brandList, ok := brands.([]string); ok && len(brandList) > 0 {
			brandInterfaces := make([]interface{}, len(brandList))
			for i, brand := range brandList {
				brandInterfaces[i] = brand
			}
			brandFilter := &types.RetrievalFilterMemberIn{
				Value: types.FilterAttribute{
					Key:   aws.String("brand"),
					Value: document.NewLazyDocument(brandInterfaces),
				},
			}
			filterConditions = append(filterConditions, brandFilter)
		}
	}

	// Rating-based filtering (enhanced from CSV metadata)
	if ratingMin, ok := filters["rating_min"]; ok {
		ratingFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("rating_average"),
				Value: document.NewLazyDocument(fmt.Sprintf("%.1f", parseFloatSafe(ratingMin))),
			},
		}
		filterConditions = append(filterConditions, ratingFilter)
	}

	if ratingCountMin, ok := filters["rating_count_min"]; ok {
		ratingCountFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("rating_count"),
				Value: document.NewLazyDocument(fmt.Sprintf("%d", parseIntSafe(ratingCountMin))),
			},
		}
		filterConditions = append(filterConditions, ratingCountFilter)
	}

	// Stock status filtering using RetrievalFilterMemberIn
	if stockStatus, ok := filters["stock_status"]; ok {
		if statusList, ok := stockStatus.([]string); ok && len(statusList) > 0 {
			statusInterfaces := make([]interface{}, len(statusList))
			for i, status := range statusList {
				statusInterfaces[i] = status
			}
			stockFilter := &types.RetrievalFilterMemberIn{
				Value: types.FilterAttribute{
					Key:   aws.String("stock_status"),
					Value: document.NewLazyDocument(statusInterfaces),
				},
			}
			filterConditions = append(filterConditions, stockFilter)
		}
	}

	// Active status filtering using RetrievalFilterMemberEquals
	if isActive, ok := filters["is_active"]; ok {
		activeFilter := &types.RetrievalFilterMemberEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("is_active"),
				Value: document.NewLazyDocument(fmt.Sprintf("%t", parseBoolSafe(isActive))),
			},
		}
		filterConditions = append(filterConditions, activeFilter)
	}

	// Popularity score filtering using GreaterThanOrEquals
	if popularityMin, ok := filters["popularity_score_min"]; ok {
		popularityFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("popularity_score"),
				Value: document.NewLazyDocument(fmt.Sprintf("%d", parseIntSafe(popularityMin))),
			},
		}
		filterConditions = append(filterConditions, popularityFilter)
	}

	// Tag-based filtering using StringContains for lifestyle tags
	if lifestyleTags, ok := filters["lifestyle_tags"]; ok {
		if tagList, ok := lifestyleTags.([]string); ok && len(tagList) > 0 {
			// Use StringContains for tag filtering
			for _, tag := range tagList {
				tagFilter := &types.RetrievalFilterMemberStringContains{
					Value: types.FilterAttribute{
						Key:   aws.String("tags"),
						Value: document.NewLazyDocument(tag),
					},
				}
				filterConditions = append(filterConditions, tagFilter)
			}
		}
	}

	// Seasonal filtering using StringContains
	if seasonalTags, ok := filters["seasonal_boost"]; ok {
		if tagList, ok := seasonalTags.([]string); ok && len(tagList) > 0 {
			for _, tag := range tagList {
				seasonalFilter := &types.RetrievalFilterMemberStringContains{
					Value: types.FilterAttribute{
						Key:   aws.String("tags"),
						Value: document.NewLazyDocument(tag),
					},
				}
				filterConditions = append(filterConditions, seasonalFilter)
			}
		}
	}

	// Apply context-specific metadata filters
	bkb.applyContextSpecificKnowledgeBaseFilters(&filterConditions, filters)

	// Return appropriate filter based on number of conditions
	if len(filterConditions) == 0 {
		return nil // No filters
	}

	if len(filterConditions) == 1 {
		return filterConditions[0] // Single filter
	}

	// Multiple conditions - combine with AND logic using RetrievalFilterMemberAndAll
	return &types.RetrievalFilterMemberAndAll{
		Value: filterConditions,
	}
}

// applyContextSpecificKnowledgeBaseFilters applies context-specific metadata filters using proper AWS SDK v2 types
func (bkb *BedrockKnowledgeBaseService) applyContextSpecificKnowledgeBaseFilters(filterConditions *[]types.RetrievalFilter, filters map[string]interface{}) {
	// Homepage boost - prioritize popular, high-rated products
	if _, ok := filters["homepage_boost"]; ok {
		homepageFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("popularity_score"),
				Value: document.NewLazyDocument("100"),
			},
		}
		*filterConditions = append(*filterConditions, homepageFilter)
	}

	// New arrivals inclusion - products created in the last 30 days
	if _, ok := filters["include_new_arrivals"]; ok {
		thirtyDaysAgo := time.Now().AddDate(0, 0, -30).Format("2006-01-02")
		newArrivalsFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("created_at"),
				Value: document.NewLazyDocument(thirtyDaysAgo),
			},
		}
		*filterConditions = append(*filterConditions, newArrivalsFilter)
	}

	// Complementary products - filter by specific categories
	if _, ok := filters["complementary_products"]; ok {
		complementaryCategories := []interface{}{"accessories", "add-ons", "complementary"}
		complementaryFilter := &types.RetrievalFilterMemberIn{
			Value: types.FilterAttribute{
				Key:   aws.String("category"),
				Value: document.NewLazyDocument(complementaryCategories),
			},
		}
		*filterConditions = append(*filterConditions, complementaryFilter)
	}

	// Frequently bought together - use popularity as proxy
	if _, ok := filters["frequently_bought_together"]; ok {
		popularFilter := &types.RetrievalFilterMemberGreaterThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("popularity_score"),
				Value: document.NewLazyDocument("75"),
			},
		}
		*filterConditions = append(*filterConditions, popularFilter)
	}

	// Quick add suitable - small, inexpensive items
	if _, ok := filters["quick_add_suitable"]; ok {
		quickAddFilter := &types.RetrievalFilterMemberLessThanOrEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("price"),
				Value: document.NewLazyDocument("100.00"),
			},
		}
		*filterConditions = append(*filterConditions, quickAddFilter)
	}

	// Category types filtering
	if categoryTypes, ok := filters["category_types"]; ok {
		if typeList, ok := categoryTypes.([]string); ok && len(typeList) > 0 {
			typeInterfaces := make([]interface{}, len(typeList))
			for i, categoryType := range typeList {
				typeInterfaces[i] = categoryType
			}
			categoryTypeFilter := &types.RetrievalFilterMemberIn{
				Value: types.FilterAttribute{
					Key:   aws.String("category"),
					Value: document.NewLazyDocument(typeInterfaces),
				},
			}
			*filterConditions = append(*filterConditions, categoryTypeFilter)
		}
	}

	// Exclusive items for premium customers
	if _, ok := filters["exclusive_items"]; ok {
		exclusiveFilter := &types.RetrievalFilterMemberEquals{
			Value: types.FilterAttribute{
				Key:   aws.String("exclusive"),
				Value: document.NewLazyDocument("true"),
			},
		}
		*filterConditions = append(*filterConditions, exclusiveFilter)
	}

	// Replenishment suitable items
	if _, ok := filters["replenishment_suitable"]; ok {
		replenishmentCategories := []interface{}{"consumables", "supplies", "replacements"}
		replenishmentFilter := &types.RetrievalFilterMemberIn{
			Value: types.FilterAttribute{
				Key:   aws.String("category"),
				Value: document.NewLazyDocument(replenishmentCategories),
			},
		}
		*filterConditions = append(*filterConditions, replenishmentFilter)
	}
}

// extractProductIDFromResult extracts product ID from Knowledge Base result
func extractProductIDFromResult(result service.KnowledgeBaseResult) uuid.UUID {
	// Try to extract product ID from metadata
	if result.Metadata != nil {
		if productIDValue, ok := result.Metadata["product_id"]; ok {
			// Handle AWS SDK v2 document types
			var productIDStr string

			// Try to extract string value from different possible types
			switch v := productIDValue.(type) {
			case string:
				productIDStr = v
			case []byte:
				productIDStr = string(v)
			case smithydocument.Unmarshaler:
				// Handle AWS SDK v2 document unmarshaler
				var unmarshaledValue interface{}
				if err := v.UnmarshalSmithyDocument(&unmarshaledValue); err == nil {
					// The unmarshaled value should be the actual string
					if str, ok := unmarshaledValue.(string); ok {
						productIDStr = str
					} else {
						productIDStr = fmt.Sprintf("%v", unmarshaledValue)
					}
				} else {
					log.Printf("Warning: Failed to unmarshal document value: %v", err)
				}
			default:
				// For other AWS SDK v2 document types, try reflection to access the value
				// This handles cases where the type might be a pointer to documentUnmarshaler
				val := reflect.ValueOf(productIDValue)
				if val.Kind() == reflect.Ptr && !val.IsNil() {
					val = val.Elem()
				}

				// Try to find a field named "value" using reflection
				if val.Kind() == reflect.Struct {
					if valueField := val.FieldByName("value"); valueField.IsValid() {
						if str, ok := valueField.Interface().(string); ok {
							productIDStr = str
						} else {
							productIDStr = fmt.Sprintf("%v", valueField.Interface())
						}
					}
				}

				// Last resort: format as string
				if productIDStr == "" {
					productIDStr = fmt.Sprintf("%v", productIDValue)
				}
			}

			// Clean up the product ID string and validate
			productIDStr = strings.TrimSpace(productIDStr)
			if productIDStr != "" && productIDStr != "null" {
				if productID, parseErr := uuid.Parse(productIDStr); parseErr == nil {
					return productID
				} else {
					log.Printf("Warning: Failed to parse product_id '%s' as UUID: %v", productIDStr, parseErr)
				}
			}
		}
	}

	// Try to extract from source URI (fallback)
	if result.Source != "" {
		// Extract from S3 URI pattern like: s3://bucket/products/product-123.csv
		parts := strings.Split(result.Source, "/")
		for _, part := range parts {
			if strings.HasPrefix(part, "product-") {
				idStr := strings.TrimPrefix(part, "product-")
				idStr = strings.TrimSuffix(idStr, ".csv")
				if productID, err := uuid.Parse(idStr); err == nil {
					return productID
				}
			}
		}
	}

	// Return zero UUID if unable to extract
	return uuid.Nil
}
