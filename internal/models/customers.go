// Code generated by SQLBoiler 4.19.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Customer is an object representing the database table.
type Customer struct {
	ID                  string            `boil:"id" json:"id" toml:"id" yaml:"id"`
	Email               string            `boil:"email" json:"email" toml:"email" yaml:"email"`
	FirstName           null.String       `boil:"first_name" json:"first_name,omitempty" toml:"first_name" yaml:"first_name,omitempty"`
	LastName            null.String       `boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	Phone               null.String       `boil:"phone" json:"phone,omitempty" toml:"phone" yaml:"phone,omitempty"`
	DateOfBirth         null.Time         `boil:"date_of_birth" json:"date_of_birth,omitempty" toml:"date_of_birth" yaml:"date_of_birth,omitempty"`
	Gender              null.String       `boil:"gender" json:"gender,omitempty" toml:"gender" yaml:"gender,omitempty"`
	PreferredLanguage   null.String       `boil:"preferred_language" json:"preferred_language,omitempty" toml:"preferred_language" yaml:"preferred_language,omitempty"`
	PreferredCategories types.Int64Array  `boil:"preferred_categories" json:"preferred_categories,omitempty" toml:"preferred_categories" yaml:"preferred_categories,omitempty"`
	PriceRangeMin       types.NullDecimal `boil:"price_range_min" json:"price_range_min,omitempty" toml:"price_range_min" yaml:"price_range_min,omitempty"`
	PriceRangeMax       types.NullDecimal `boil:"price_range_max" json:"price_range_max,omitempty" toml:"price_range_max" yaml:"price_range_max,omitempty"`
	PreferredBrands     types.StringArray `boil:"preferred_brands" json:"preferred_brands,omitempty" toml:"preferred_brands" yaml:"preferred_brands,omitempty"`
	Location            null.JSON         `boil:"location" json:"location,omitempty" toml:"location" yaml:"location,omitempty"`
	LifestyleTags       types.StringArray `boil:"lifestyle_tags" json:"lifestyle_tags,omitempty" toml:"lifestyle_tags" yaml:"lifestyle_tags,omitempty"`
	IsPremium           null.Bool         `boil:"is_premium" json:"is_premium,omitempty" toml:"is_premium" yaml:"is_premium,omitempty"`
	TotalSpent          types.NullDecimal `boil:"total_spent" json:"total_spent,omitempty" toml:"total_spent" yaml:"total_spent,omitempty"`
	OrderCount          null.Int          `boil:"order_count" json:"order_count,omitempty" toml:"order_count" yaml:"order_count,omitempty"`
	CreatedAt           null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt           null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`

	R *customerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L customerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CustomerColumns = struct {
	ID                  string
	Email               string
	FirstName           string
	LastName            string
	Phone               string
	DateOfBirth         string
	Gender              string
	PreferredLanguage   string
	PreferredCategories string
	PriceRangeMin       string
	PriceRangeMax       string
	PreferredBrands     string
	Location            string
	LifestyleTags       string
	IsPremium           string
	TotalSpent          string
	OrderCount          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "id",
	Email:               "email",
	FirstName:           "first_name",
	LastName:            "last_name",
	Phone:               "phone",
	DateOfBirth:         "date_of_birth",
	Gender:              "gender",
	PreferredLanguage:   "preferred_language",
	PreferredCategories: "preferred_categories",
	PriceRangeMin:       "price_range_min",
	PriceRangeMax:       "price_range_max",
	PreferredBrands:     "preferred_brands",
	Location:            "location",
	LifestyleTags:       "lifestyle_tags",
	IsPremium:           "is_premium",
	TotalSpent:          "total_spent",
	OrderCount:          "order_count",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
}

var CustomerTableColumns = struct {
	ID                  string
	Email               string
	FirstName           string
	LastName            string
	Phone               string
	DateOfBirth         string
	Gender              string
	PreferredLanguage   string
	PreferredCategories string
	PriceRangeMin       string
	PriceRangeMax       string
	PreferredBrands     string
	Location            string
	LifestyleTags       string
	IsPremium           string
	TotalSpent          string
	OrderCount          string
	CreatedAt           string
	UpdatedAt           string
}{
	ID:                  "customers.id",
	Email:               "customers.email",
	FirstName:           "customers.first_name",
	LastName:            "customers.last_name",
	Phone:               "customers.phone",
	DateOfBirth:         "customers.date_of_birth",
	Gender:              "customers.gender",
	PreferredLanguage:   "customers.preferred_language",
	PreferredCategories: "customers.preferred_categories",
	PriceRangeMin:       "customers.price_range_min",
	PriceRangeMax:       "customers.price_range_max",
	PreferredBrands:     "customers.preferred_brands",
	Location:            "customers.location",
	LifestyleTags:       "customers.lifestyle_tags",
	IsPremium:           "customers.is_premium",
	TotalSpent:          "customers.total_spent",
	OrderCount:          "customers.order_count",
	CreatedAt:           "customers.created_at",
	UpdatedAt:           "customers.updated_at",
}

// Generated where

type whereHelpertypes_Int64Array struct{ field string }

func (w whereHelpertypes_Int64Array) EQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_Int64Array) NEQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_Int64Array) LT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Int64Array) LTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Int64Array) GT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Int64Array) GTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_Int64Array) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_Int64Array) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var CustomerWhere = struct {
	ID                  whereHelperstring
	Email               whereHelperstring
	FirstName           whereHelpernull_String
	LastName            whereHelpernull_String
	Phone               whereHelpernull_String
	DateOfBirth         whereHelpernull_Time
	Gender              whereHelpernull_String
	PreferredLanguage   whereHelpernull_String
	PreferredCategories whereHelpertypes_Int64Array
	PriceRangeMin       whereHelpertypes_NullDecimal
	PriceRangeMax       whereHelpertypes_NullDecimal
	PreferredBrands     whereHelpertypes_StringArray
	Location            whereHelpernull_JSON
	LifestyleTags       whereHelpertypes_StringArray
	IsPremium           whereHelpernull_Bool
	TotalSpent          whereHelpertypes_NullDecimal
	OrderCount          whereHelpernull_Int
	CreatedAt           whereHelpernull_Time
	UpdatedAt           whereHelpernull_Time
}{
	ID:                  whereHelperstring{field: "\"customers\".\"id\""},
	Email:               whereHelperstring{field: "\"customers\".\"email\""},
	FirstName:           whereHelpernull_String{field: "\"customers\".\"first_name\""},
	LastName:            whereHelpernull_String{field: "\"customers\".\"last_name\""},
	Phone:               whereHelpernull_String{field: "\"customers\".\"phone\""},
	DateOfBirth:         whereHelpernull_Time{field: "\"customers\".\"date_of_birth\""},
	Gender:              whereHelpernull_String{field: "\"customers\".\"gender\""},
	PreferredLanguage:   whereHelpernull_String{field: "\"customers\".\"preferred_language\""},
	PreferredCategories: whereHelpertypes_Int64Array{field: "\"customers\".\"preferred_categories\""},
	PriceRangeMin:       whereHelpertypes_NullDecimal{field: "\"customers\".\"price_range_min\""},
	PriceRangeMax:       whereHelpertypes_NullDecimal{field: "\"customers\".\"price_range_max\""},
	PreferredBrands:     whereHelpertypes_StringArray{field: "\"customers\".\"preferred_brands\""},
	Location:            whereHelpernull_JSON{field: "\"customers\".\"location\""},
	LifestyleTags:       whereHelpertypes_StringArray{field: "\"customers\".\"lifestyle_tags\""},
	IsPremium:           whereHelpernull_Bool{field: "\"customers\".\"is_premium\""},
	TotalSpent:          whereHelpertypes_NullDecimal{field: "\"customers\".\"total_spent\""},
	OrderCount:          whereHelpernull_Int{field: "\"customers\".\"order_count\""},
	CreatedAt:           whereHelpernull_Time{field: "\"customers\".\"created_at\""},
	UpdatedAt:           whereHelpernull_Time{field: "\"customers\".\"updated_at\""},
}

// CustomerRels is where relationship names are stored.
var CustomerRels = struct {
	CartItems          string
	CustomerActivities string
	Orders             string
	ProductReviews     string
	RecommendationLogs string
	WishlistItems      string
}{
	CartItems:          "CartItems",
	CustomerActivities: "CustomerActivities",
	Orders:             "Orders",
	ProductReviews:     "ProductReviews",
	RecommendationLogs: "RecommendationLogs",
	WishlistItems:      "WishlistItems",
}

// customerR is where relationships are stored.
type customerR struct {
	CartItems          CartItemSlice          `boil:"CartItems" json:"CartItems" toml:"CartItems" yaml:"CartItems"`
	CustomerActivities CustomerActivitySlice  `boil:"CustomerActivities" json:"CustomerActivities" toml:"CustomerActivities" yaml:"CustomerActivities"`
	Orders             OrderSlice             `boil:"Orders" json:"Orders" toml:"Orders" yaml:"Orders"`
	ProductReviews     ProductReviewSlice     `boil:"ProductReviews" json:"ProductReviews" toml:"ProductReviews" yaml:"ProductReviews"`
	RecommendationLogs RecommendationLogSlice `boil:"RecommendationLogs" json:"RecommendationLogs" toml:"RecommendationLogs" yaml:"RecommendationLogs"`
	WishlistItems      WishlistItemSlice      `boil:"WishlistItems" json:"WishlistItems" toml:"WishlistItems" yaml:"WishlistItems"`
}

// NewStruct creates a new relationship struct
func (*customerR) NewStruct() *customerR {
	return &customerR{}
}

func (o *Customer) GetCartItems() CartItemSlice {
	if o == nil {
		return nil
	}

	return o.R.GetCartItems()
}

func (r *customerR) GetCartItems() CartItemSlice {
	if r == nil {
		return nil
	}

	return r.CartItems
}

func (o *Customer) GetCustomerActivities() CustomerActivitySlice {
	if o == nil {
		return nil
	}

	return o.R.GetCustomerActivities()
}

func (r *customerR) GetCustomerActivities() CustomerActivitySlice {
	if r == nil {
		return nil
	}

	return r.CustomerActivities
}

func (o *Customer) GetOrders() OrderSlice {
	if o == nil {
		return nil
	}

	return o.R.GetOrders()
}

func (r *customerR) GetOrders() OrderSlice {
	if r == nil {
		return nil
	}

	return r.Orders
}

func (o *Customer) GetProductReviews() ProductReviewSlice {
	if o == nil {
		return nil
	}

	return o.R.GetProductReviews()
}

func (r *customerR) GetProductReviews() ProductReviewSlice {
	if r == nil {
		return nil
	}

	return r.ProductReviews
}

func (o *Customer) GetRecommendationLogs() RecommendationLogSlice {
	if o == nil {
		return nil
	}

	return o.R.GetRecommendationLogs()
}

func (r *customerR) GetRecommendationLogs() RecommendationLogSlice {
	if r == nil {
		return nil
	}

	return r.RecommendationLogs
}

func (o *Customer) GetWishlistItems() WishlistItemSlice {
	if o == nil {
		return nil
	}

	return o.R.GetWishlistItems()
}

func (r *customerR) GetWishlistItems() WishlistItemSlice {
	if r == nil {
		return nil
	}

	return r.WishlistItems
}

// customerL is where Load methods for each relationship are stored.
type customerL struct{}

var (
	customerAllColumns            = []string{"id", "email", "first_name", "last_name", "phone", "date_of_birth", "gender", "preferred_language", "preferred_categories", "price_range_min", "price_range_max", "preferred_brands", "location", "lifestyle_tags", "is_premium", "total_spent", "order_count", "created_at", "updated_at"}
	customerColumnsWithoutDefault = []string{"email"}
	customerColumnsWithDefault    = []string{"id", "first_name", "last_name", "phone", "date_of_birth", "gender", "preferred_language", "preferred_categories", "price_range_min", "price_range_max", "preferred_brands", "location", "lifestyle_tags", "is_premium", "total_spent", "order_count", "created_at", "updated_at"}
	customerPrimaryKeyColumns     = []string{"id"}
	customerGeneratedColumns      = []string{}
)

type (
	// CustomerSlice is an alias for a slice of pointers to Customer.
	// This should almost always be used instead of []Customer.
	CustomerSlice []*Customer
	// CustomerHook is the signature for custom Customer hook methods
	CustomerHook func(context.Context, boil.ContextExecutor, *Customer) error

	customerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	customerType                 = reflect.TypeOf(&Customer{})
	customerMapping              = queries.MakeStructMapping(customerType)
	customerPrimaryKeyMapping, _ = queries.BindMapping(customerType, customerMapping, customerPrimaryKeyColumns)
	customerInsertCacheMut       sync.RWMutex
	customerInsertCache          = make(map[string]insertCache)
	customerUpdateCacheMut       sync.RWMutex
	customerUpdateCache          = make(map[string]updateCache)
	customerUpsertCacheMut       sync.RWMutex
	customerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var customerAfterSelectMu sync.Mutex
var customerAfterSelectHooks []CustomerHook

var customerBeforeInsertMu sync.Mutex
var customerBeforeInsertHooks []CustomerHook
var customerAfterInsertMu sync.Mutex
var customerAfterInsertHooks []CustomerHook

var customerBeforeUpdateMu sync.Mutex
var customerBeforeUpdateHooks []CustomerHook
var customerAfterUpdateMu sync.Mutex
var customerAfterUpdateHooks []CustomerHook

var customerBeforeDeleteMu sync.Mutex
var customerBeforeDeleteHooks []CustomerHook
var customerAfterDeleteMu sync.Mutex
var customerAfterDeleteHooks []CustomerHook

var customerBeforeUpsertMu sync.Mutex
var customerBeforeUpsertHooks []CustomerHook
var customerAfterUpsertMu sync.Mutex
var customerAfterUpsertHooks []CustomerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Customer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Customer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Customer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Customer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Customer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Customer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Customer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Customer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Customer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCustomerHook registers your hook function for all future operations.
func AddCustomerHook(hookPoint boil.HookPoint, customerHook CustomerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		customerAfterSelectMu.Lock()
		customerAfterSelectHooks = append(customerAfterSelectHooks, customerHook)
		customerAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		customerBeforeInsertMu.Lock()
		customerBeforeInsertHooks = append(customerBeforeInsertHooks, customerHook)
		customerBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		customerAfterInsertMu.Lock()
		customerAfterInsertHooks = append(customerAfterInsertHooks, customerHook)
		customerAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		customerBeforeUpdateMu.Lock()
		customerBeforeUpdateHooks = append(customerBeforeUpdateHooks, customerHook)
		customerBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		customerAfterUpdateMu.Lock()
		customerAfterUpdateHooks = append(customerAfterUpdateHooks, customerHook)
		customerAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		customerBeforeDeleteMu.Lock()
		customerBeforeDeleteHooks = append(customerBeforeDeleteHooks, customerHook)
		customerBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		customerAfterDeleteMu.Lock()
		customerAfterDeleteHooks = append(customerAfterDeleteHooks, customerHook)
		customerAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		customerBeforeUpsertMu.Lock()
		customerBeforeUpsertHooks = append(customerBeforeUpsertHooks, customerHook)
		customerBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		customerAfterUpsertMu.Lock()
		customerAfterUpsertHooks = append(customerAfterUpsertHooks, customerHook)
		customerAfterUpsertMu.Unlock()
	}
}

// One returns a single customer record from the query.
func (q customerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Customer, error) {
	o := &Customer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for customers")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Customer records from the query.
func (q customerQuery) All(ctx context.Context, exec boil.ContextExecutor) (CustomerSlice, error) {
	var o []*Customer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Customer slice")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Customer records in the query.
func (q customerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count customers rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q customerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if customers exists")
	}

	return count > 0, nil
}

// CartItems retrieves all the cart_item's CartItems with an executor.
func (o *Customer) CartItems(mods ...qm.QueryMod) cartItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"cart_items\".\"customer_id\"=?", o.ID),
	)

	return CartItems(queryMods...)
}

// CustomerActivities retrieves all the customer_activity's CustomerActivities with an executor.
func (o *Customer) CustomerActivities(mods ...qm.QueryMod) customerActivityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"customer_activities\".\"customer_id\"=?", o.ID),
	)

	return CustomerActivities(queryMods...)
}

// Orders retrieves all the order's Orders with an executor.
func (o *Customer) Orders(mods ...qm.QueryMod) orderQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"orders\".\"customer_id\"=?", o.ID),
	)

	return Orders(queryMods...)
}

// ProductReviews retrieves all the product_review's ProductReviews with an executor.
func (o *Customer) ProductReviews(mods ...qm.QueryMod) productReviewQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"product_reviews\".\"customer_id\"=?", o.ID),
	)

	return ProductReviews(queryMods...)
}

// RecommendationLogs retrieves all the recommendation_log's RecommendationLogs with an executor.
func (o *Customer) RecommendationLogs(mods ...qm.QueryMod) recommendationLogQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"recommendation_logs\".\"customer_id\"=?", o.ID),
	)

	return RecommendationLogs(queryMods...)
}

// WishlistItems retrieves all the wishlist_item's WishlistItems with an executor.
func (o *Customer) WishlistItems(mods ...qm.QueryMod) wishlistItemQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"wishlist_items\".\"customer_id\"=?", o.ID),
	)

	return WishlistItems(queryMods...)
}

// LoadCartItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadCartItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`cart_items`),
		qm.WhereIn(`cart_items.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load cart_items")
	}

	var resultSlice []*CartItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice cart_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on cart_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cart_items")
	}

	if len(cartItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CartItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cartItemR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.CartItems = append(local.R.CartItems, foreign)
				if foreign.R == nil {
					foreign.R = &cartItemR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadCustomerActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadCustomerActivities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`customer_activities`),
		qm.WhereIn(`customer_activities.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_activities")
	}

	var resultSlice []*CustomerActivity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_activities")
	}

	if len(customerActivityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerActivities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerActivityR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.CustomerActivities = append(local.R.CustomerActivities, foreign)
				if foreign.R == nil {
					foreign.R = &customerActivityR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadOrders allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadOrders(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`orders`),
		qm.WhereIn(`orders.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load orders")
	}

	var resultSlice []*Order
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice orders")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on orders")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for orders")
	}

	if len(orderAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Orders = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.Orders = append(local.R.Orders, foreign)
				if foreign.R == nil {
					foreign.R = &orderR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadProductReviews allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadProductReviews(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`product_reviews`),
		qm.WhereIn(`product_reviews.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load product_reviews")
	}

	var resultSlice []*ProductReview
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice product_reviews")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on product_reviews")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_reviews")
	}

	if len(productReviewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ProductReviews = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &productReviewR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.ProductReviews = append(local.R.ProductReviews, foreign)
				if foreign.R == nil {
					foreign.R = &productReviewR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadRecommendationLogs allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadRecommendationLogs(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`recommendation_logs`),
		qm.WhereIn(`recommendation_logs.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load recommendation_logs")
	}

	var resultSlice []*RecommendationLog
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice recommendation_logs")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on recommendation_logs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for recommendation_logs")
	}

	if len(recommendationLogAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.RecommendationLogs = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &recommendationLogR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.RecommendationLogs = append(local.R.RecommendationLogs, foreign)
				if foreign.R == nil {
					foreign.R = &recommendationLogR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// LoadWishlistItems allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadWishlistItems(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		var ok bool
		object, ok = maybeCustomer.(*Customer)
		if !ok {
			object = new(Customer)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeCustomer))
			}
		}
	} else {
		s, ok := maybeCustomer.(*[]*Customer)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeCustomer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeCustomer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`wishlist_items`),
		qm.WhereIn(`wishlist_items.customer_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load wishlist_items")
	}

	var resultSlice []*WishlistItem
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice wishlist_items")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on wishlist_items")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for wishlist_items")
	}

	if len(wishlistItemAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.WishlistItems = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &wishlistItemR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.WishlistItems = append(local.R.WishlistItems, foreign)
				if foreign.R == nil {
					foreign.R = &wishlistItemR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// AddCartItems adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.CartItems.
// Sets related.R.Customer appropriately.
func (o *Customer) AddCartItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CartItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"cart_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, cartItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			CartItems: related,
		}
	} else {
		o.R.CartItems = append(o.R.CartItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cartItemR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddCustomerActivities adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.CustomerActivities.
// Sets related.R.Customer appropriately.
func (o *Customer) AddCustomerActivities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerActivity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"customer_activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, customerActivityPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			CustomerActivities: related,
		}
	} else {
		o.R.CustomerActivities = append(o.R.CustomerActivities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerActivityR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddOrders adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.Orders.
// Sets related.R.Customer appropriately.
func (o *Customer) AddOrders(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Order) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"orders\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, orderPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			Orders: related,
		}
	} else {
		o.R.Orders = append(o.R.Orders, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddProductReviews adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.ProductReviews.
// Sets related.R.Customer appropriately.
func (o *Customer) AddProductReviews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ProductReview) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"product_reviews\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, productReviewPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			ProductReviews: related,
		}
	} else {
		o.R.ProductReviews = append(o.R.ProductReviews, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &productReviewR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddRecommendationLogs adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.RecommendationLogs.
// Sets related.R.Customer appropriately.
func (o *Customer) AddRecommendationLogs(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RecommendationLog) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"recommendation_logs\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, recommendationLogPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			RecommendationLogs: related,
		}
	} else {
		o.R.RecommendationLogs = append(o.R.RecommendationLogs, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &recommendationLogR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// AddWishlistItems adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.WishlistItems.
// Sets related.R.Customer appropriately.
func (o *Customer) AddWishlistItems(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*WishlistItem) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"wishlist_items\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"customer_id"}),
				strmangle.WhereClause("\"", "\"", 2, wishlistItemPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			WishlistItems: related,
		}
	} else {
		o.R.WishlistItems = append(o.R.WishlistItems, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &wishlistItemR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// Customers retrieves all the records using an executor.
func Customers(mods ...qm.QueryMod) customerQuery {
	mods = append(mods, qm.From("\"customers\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"customers\".*"})
	}

	return customerQuery{q}
}

// FindCustomer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCustomer(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Customer, error) {
	customerObj := &Customer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"customers\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, customerObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from customers")
	}

	if err = customerObj.doAfterSelectHooks(ctx, exec); err != nil {
		return customerObj, err
	}

	return customerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Customer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no customers provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	customerInsertCacheMut.RLock()
	cache, cached := customerInsertCache[key]
	customerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(customerType, customerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"customers\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"customers\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into customers")
	}

	if !cached {
		customerInsertCacheMut.Lock()
		customerInsertCache[key] = cache
		customerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Customer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Customer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	customerUpdateCacheMut.RLock()
	cache, cached := customerUpdateCache[key]
	customerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update customers, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"customers\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, customerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, append(wl, customerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update customers row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for customers")
	}

	if !cached {
		customerUpdateCacheMut.Lock()
		customerUpdateCache[key] = cache
		customerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q customerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for customers")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CustomerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"customers\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, customerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all customer")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Customer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no customers provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	customerUpsertCacheMut.RLock()
	cache, cached := customerUpsertCache[key]
	customerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert customers, could not build update column list")
		}

		ret := strmangle.SetComplement(customerAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(customerPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert customers, could not build conflict column list")
			}

			conflict = make([]string, len(customerPrimaryKeyColumns))
			copy(conflict, customerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"customers\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(customerType, customerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert customers")
	}

	if !cached {
		customerUpsertCacheMut.Lock()
		customerUpsertCache[key] = cache
		customerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Customer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Customer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Customer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), customerPrimaryKeyMapping)
	sql := "DELETE FROM \"customers\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for customers")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q customerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no customerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customers")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customers")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CustomerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(customerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"customers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, customerPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customers")
	}

	if len(customerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Customer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCustomer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CustomerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CustomerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"customers\".* FROM \"customers\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, customerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CustomerSlice")
	}

	*o = slice

	return nil
}

// CustomerExists checks if the Customer row exists.
func CustomerExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"customers\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if customers exists")
	}

	return exists, nil
}

// Exists checks if the Customer row exists.
func (o *Customer) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return CustomerExists(ctx, exec, o.ID)
}
